name: Build and Push Docker Images

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: petman_secrets
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./petmanagement_backend
        file: ./petmanagement_backend/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./petmanagement_frontend
        file: ./petmanagement_frontend/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: petman_secrets
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Deploy to EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # Create application directory
          mkdir -p /home/${{ secrets.EC2_USERNAME }}/petmanagement
          cd /home/${{ secrets.EC2_USERNAME }}/petmanagement
          
          # Create the monitoring script directly
          cat > monitor-logs.sh << 'SCRIPT_EOF'
          #!/bin/bash
          
          # Pet Finder Log Monitor Script
          LOG_FILE="/var/log/petfinder.log"
          ALERT_FILE="/var/log/petfinder-alerts.log"
          ERROR_THRESHOLD=5
          TIME_WINDOW=60
          TEMP_ERROR_FILE="/tmp/petfinder_errors.tmp"
          
          # Create log files if they don't exist
          sudo touch "$LOG_FILE" "$ALERT_FILE" 2>/dev/null || true
          sudo chmod 666 "$LOG_FILE" "$ALERT_FILE" 2>/dev/null || true
          
          # Function to log alerts
          log_alert() {
              local message="$1"
              local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
              echo "[$timestamp] ALERT: $message" | sudo tee -a "$ALERT_FILE"
              echo "[$timestamp] ALERT: $message"
          }
          
          # Function to simulate log entries for testing
          simulate_logs() {
              echo "Simulating log entries for testing..."
              local timestamp=$(date '+%Y-%m-%dT%H:%M:%S')
              
              # Simulate error logs
              for i in {1..6}; do
                  echo "[$timestamp] ERROR: Database connection failed - attempt $i" | sudo tee -a "$LOG_FILE"
                  echo "[$timestamp] ::ffff:127.0.0.1 - - \"POST /v1/users/signup HTTP/1.1\" 500 -" | sudo tee -a "$LOG_FILE"
              done
              
              echo "Simulated logs added to $LOG_FILE"
          }
          
          # Function to monitor errors
          monitor_errors() {
              echo "Monitoring $LOG_FILE for errors..."
              
              # Count recent errors
              if [[ -f "$LOG_FILE" ]]; then
                  error_count=$(grep -c -E "(HTTP/1\.[01]\" 5[0-9][0-9]|ERROR|Error|error)" "$LOG_FILE" 2>/dev/null || echo "0")
                  echo "Found $error_count errors in log file"
                  
                  if [[ $error_count -ge $ERROR_THRESHOLD ]]; then
                      log_alert "High error rate detected: $error_count errors found"
                  else
                      echo "Error count ($error_count) is below threshold ($ERROR_THRESHOLD)"
                  fi
              else
                  echo "Log file $LOG_FILE not found"
              fi
          }
          
          # Main execution
          case "${1:-monitor}" in
              "simulate")
                  simulate_logs
                  ;;
              "monitor")
                  echo "Starting Pet Finder log monitoring..."
                  monitor_errors
                  echo "Monitoring complete. Check $ALERT_FILE for any alerts."
                  ;;
              *)
                  echo "Usage: $0 [monitor|simulate]"
                  exit 1
                  ;;
          esac
          SCRIPT_EOF
          
          # Create nginx.conf
          cat > nginx.conf << 'NGINX_EOF'
          events {
              worker_connections 1024;
          }

          http {
              upstream frontend {
                  server frontend:4000;
              }

              upstream backend {
                  server backend:5000;
              }

              server {
                  listen 80;
                  server_name localhost;

                  # Backend API routes (must come before frontend catch-all)
                  location /v1/ {
                      proxy_pass http://backend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $host;
                  }

                  # Backend uploads
                  location /uploads/ {
                      proxy_pass http://backend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }

                  # Frontend routes (catch-all, must be last)
                  location / {
                      proxy_pass http://frontend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $host;
                  }
              }
          }
          NGINX_EOF
          
          # Create docker-compose.yml if it doesn't exist
          cat > docker-compose.yml << 'EOF'
          services:
            mongodb:
              image: mongo:7
              container_name: petmanagement_mongodb
              restart: unless-stopped
              environment:
                MONGO_INITDB_ROOT_USERNAME: admin
                MONGO_INITDB_ROOT_PASSWORD: password123
                MONGO_INITDB_DATABASE: petmanagement
              ports:
                - "27017:27017"
              volumes:
                - mongodb_data:/data/db
              networks:
                - petmanagement_network

            backend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
              container_name: petmanagement_backend
              restart: unless-stopped
              environment:
                - PORT=5000
                - NODE_ENV=production
                - SECRET_KEY=FrgtBHYtiXEr
                - KEY=Gt!@3BRGhBytujsSer4^U6vtu*etseVg
                - IV=Vgq^btht&8*!@cfrPnhuCDQ@fv%cRfgY
                - MONGODB_URI=mongodb://admin:password123@mongodb:27017/petmanagement?authSource=admin
              ports:
                - "5000:5000"
              depends_on:
                - mongodb
              volumes:
                - ./logs:/app/logs
                - ./uploads:/app/app/routes/uploads
              networks:
                - petmanagement_network

            frontend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
              container_name: petmanagement_frontend
              restart: unless-stopped
              environment:
                - PORT=4000
                - NODE_ENV=production
              ports:
                - "4000:4000"
              depends_on:
                - backend
              networks:
                - petmanagement_network

            nginx:
              image: nginx:alpine
              container_name: petmanagement_nginx
              restart: unless-stopped
              ports:
                - "80:80"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
              depends_on:
                - frontend
                - backend
              networks:
                - petmanagement_network

          volumes:
            mongodb_data:

          networks:
            petmanagement_network:
              driver: bridge
          EOF
          
          # Pull latest images (force fresh pull)
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
          
          # Remove old images to force fresh deployment
          docker rmi $(docker images -q ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend) || true
          
          # Stop existing containers
          docker-compose down || true
          
          # Start new containers
          docker-compose up -d
          
          # Wait for services to be ready
          sleep 30
          
          # Install required tools
          sudo apt update
          sudo DEBIAN_FRONTEND=noninteractive apt install -y jq
          
          # Install ngrok if not exists
          if ! command -v ngrok &> /dev/null; then
            curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
            echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
            sudo apt update && sudo DEBIAN_FRONTEND=noninteractive apt install ngrok -y
          fi
          
          # Kill existing ngrok processes
          pkill ngrok || true
          sleep 2
          
          # Start ngrok for nginx (port 80)
          nohup ngrok http 80 > /tmp/ngrok.log 2>&1 &
          sleep 15
          
          # Get the ngrok URL
          NGROK_URL=$(curl -s localhost:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url // empty' 2>/dev/null || echo "")
          
          if [ -z "$NGROK_URL" ] || [ "$NGROK_URL" = "null" ]; then
            NGROK_URL=$(grep -o 'https://[^[:space:]]*\.ngrok\.io' /tmp/ngrok.log 2>/dev/null | head -1 || echo "Check EC2 manually")
          fi
          
          echo "üöÄ Application accessible at: $NGROK_URL"
          echo "üîß API accessible at: $NGROK_URL/v1/"
          
          # Save URL
          echo "$NGROK_URL" > /home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt
          
          # Clean up old images
          docker image prune -f
          
          # Deploy monitoring script
          chmod +x monitor-logs.sh
          sudo cp monitor-logs.sh /usr/local/bin/
          
          # Create log directory and files
          sudo mkdir -p /var/log
          sudo touch /var/log/petfinder.log /var/log/petfinder-alerts.log
          sudo chmod 666 /var/log/petfinder.log /var/log/petfinder-alerts.log
          
          # Test the monitoring script
          echo "Testing log monitoring script..."
          /usr/local/bin/monitor-logs.sh simulate
          /usr/local/bin/monitor-logs.sh monitor

    - name: Get ngrok URL
      id: get-url
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # Read the saved URL from file
          if [ -f "/home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt" ]; then
            NGROK_URL=$(cat /home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt)
          else
            NGROK_URL="Deployment completed - check EC2 for ngrok URL"
          fi
          echo "url=$NGROK_URL"

    - name: Display deployment info
      run: |
        echo "üöÄ Deployment Successful!"
        echo "üì± Live Application: ${{ steps.get-url.outputs.url }}"
        echo "üîß Backend API: ${{ steps.get-url.outputs.url }}/v1/"
        echo "‚è∞ Deployed at: $(date)"