name: Build and Push Docker Images

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: petman_secrets
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./petmanagement_backend
        file: ./petmanagement_backend/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./petmanagement_frontend
        file: ./petmanagement_frontend/Dockerfile
        push: true
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
          ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: petman_secrets
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Deploy to EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # Create application directory
          mkdir -p /home/${{ secrets.EC2_USERNAME }}/petmanagement
          cd /home/${{ secrets.EC2_USERNAME }}/petmanagement
          
          # Create docker-compose.yml if it doesn't exist
          cat > docker-compose.yml << 'EOF'
          services:
            mongodb:
              image: mongo:7
              container_name: petmanagement_mongodb
              restart: unless-stopped
              environment:
                MONGO_INITDB_ROOT_USERNAME: admin
                MONGO_INITDB_ROOT_PASSWORD: password123
                MONGO_INITDB_DATABASE: petmanagement
              ports:
                - "27017:27017"
              volumes:
                - mongodb_data:/data/db
              networks:
                - petmanagement_network

            backend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
              container_name: petmanagement_backend
              restart: unless-stopped
              environment:
                - PORT=5000
                - NODE_ENV=production
                - SECRET_KEY=FrgtBHYtiXEr
                - KEY=Gt!@3BRGhBytujsSer4^U6vtu*etseVg
                - IV=Vgq^btht&8*!@cfrPnhuCDQ@fv%cRfgY
                - MONGODB_URI=mongodb://admin:password123@mongodb:27017/petmanagement?authSource=admin
              ports:
                - "5000:5000"
              depends_on:
                - mongodb
              volumes:
                - ./logs:/app/logs
                - ./uploads:/app/app/routes/uploads
              networks:
                - petmanagement_network

            frontend:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
              container_name: petmanagement_frontend
              restart: unless-stopped
              environment:
                - PORT=4000
                - NODE_ENV=production
              ports:
                - "4000:4000"
              depends_on:
                - backend
              networks:
                - petmanagement_network

            nginx:
              image: nginx:alpine
              container_name: petmanagement_nginx
              restart: unless-stopped
              ports:
                - "80:80"
              depends_on:
                - frontend
                - backend
              networks:
                - petmanagement_network

          volumes:
            mongodb_data:

          networks:
            petmanagement_network:
              driver: bridge
          EOF
          
          # Pull latest images
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-backend:latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/petmanagement-frontend:latest
          
          # Stop existing containers
          docker-compose down || true
          
          # Start new containers
          docker-compose up -d
          
          # Wait for services to be ready
          sleep 30
          
          # Install required tools
          sudo apt update
          sudo DEBIAN_FRONTEND=noninteractive apt install -y jq
          
          # Install ngrok if not exists
          if ! command -v ngrok &> /dev/null; then
            curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
            echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
            sudo apt update && sudo DEBIAN_FRONTEND=noninteractive apt install ngrok -y
          fi
          
          # Kill existing ngrok processes
          pkill ngrok || true
          sleep 2
          
          # Start ngrok in background
          nohup ngrok http 4000 > /tmp/ngrok.log 2>&1 &
          sleep 15
          
          # Extract and display the public URL with better error handling
          NGROK_URL=""
          for i in {1..5}; do
            NGROK_URL=$(curl -s localhost:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url // empty' 2>/dev/null || echo "")
            if [ ! -z "$NGROK_URL" ] && [ "$NGROK_URL" != "null" ]; then
              break
            fi
            echo "Attempt $i: Waiting for ngrok to start..."
            sleep 5
          done
          
          if [ -z "$NGROK_URL" ] || [ "$NGROK_URL" = "null" ]; then
            echo "‚ö†Ô∏è Could not get ngrok URL, checking manually..."
            # Fallback: try to extract from log
            NGROK_URL=$(grep -o 'https://[^[:space:]]*\.ngrok\.io' /tmp/ngrok.log 2>/dev/null | head -1 || echo "Check EC2 manually")
          fi
          
          echo "üöÄ Application is now accessible at: $NGROK_URL"
          
          # Save URL to file for future reference
          echo "$NGROK_URL" > /home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt
          
          # Clean up old images
          docker image prune -f

    - name: Get ngrok URL
      id: get-url
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # Read the saved URL from file
          if [ -f "/home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt" ]; then
            NGROK_URL=$(cat /home/${{ secrets.EC2_USERNAME }}/petmanagement/ngrok_url.txt)
          else
            NGROK_URL="Deployment completed - check EC2 for ngrok URL"
          fi
          echo "url=$NGROK_URL"

    - name: Create deployment comment
      uses: actions/github-script@v7
      with:
        script: |
          const url = '${{ steps.get-url.outputs.url }}';
          github.rest.repos.createCommitComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            commit_sha: context.sha,
            body: `üöÄ **Deployment Successful!**\n\nüì± **Live Application**: ${url}\n\nüîß **Services**:\n- Frontend: ${url}\n- Backend API: ${url.replace('https://', 'https://').replace('.ngrok.io', '.ngrok.io')}/v1/\n\n‚è∞ Deployed at: ${new Date().toISOString()}`
          })